<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Verb Phrase Match Game</title>
  <style>
    :root{
      --bg:#0b1020;
      --panel:#121a33;
      --card:#18224a;
      --card2:#18224a;
      --text:#e9ecff;
      --muted:#a8b0d6;
      --good:#2ee59d;
      --bad:#ff5a7a;
      --warn:#ffd166;
      --accent:#76c8ff;
      --line:#2a3568;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
    }
    *{box-sizing:border-box}
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      background: radial-gradient(1200px 800px at 20% 10%, #19235a 0%, var(--bg) 45%, #070a14 100%);
      color: var(--text);
      min-height: 100vh;
      display:flex;
      align-items:center;
      justify-content:center;
      padding: 18px;
    }
    .app{
      width:min(1100px, 100%);
      background: rgba(18,26,51,.75);
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: calc(var(--radius) + 8px);
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    header{
      padding: 18px 18px 12px;
      display:flex;
      flex-wrap:wrap;
      gap: 12px;
      align-items:center;
      justify-content:space-between;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,0));
    }
    .title{
      display:flex;
      flex-direction:column;
      gap:4px;
    }
    h1{
      margin:0;
      font-size: 18px;
      letter-spacing:.2px;
    }
    .subtitle{
      margin:0;
      color: var(--muted);
      font-size: 13px;
      line-height: 1.25;
    }
    .controls{
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap:wrap;
      justify-content:flex-end;
    }
    .pill{
      display:flex;
      gap:10px;
      align-items:center;
      padding: 10px 12px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.10);
      color: var(--text);
      font-size: 13px;
      white-space:nowrap;
      font-variant-numeric: tabular-nums;
    }
    .btn{
      appearance:none;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.08);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 999px;
      cursor:pointer;
      font-weight:600;
      font-size: 13px;
      transition: transform .05s ease, background .2s ease, border-color .2s ease;
    }
    .btn:hover{ background: rgba(255,255,255,.12); }
    .btn:active{ transform: translateY(1px); }
    .btn:focus{ outline: 2px solid rgba(46,229,157,.45); outline-offset: 2px; }

    main{
      padding: 16px 18px 18px;
    }

    .progressWrap{
      margin: 2px 0 14px;
      height: 10px;
      border-radius: 999px;
      background: rgba(255,255,255,.06);
      border: 1px solid rgba(255,255,255,.1);
      overflow: hidden;
    }
    .progressBar{
      height: 100%;
      width: 0;
      background: linear-gradient(90deg, var(--good), var(--accent));
      transition: width .25s ease;
    }

    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 14px;
    }
    @media (max-width: 820px){
      .grid{ grid-template-columns: 1fr; }
    }

    .col{
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      border-radius: var(--radius);
      overflow:hidden;
    }
    .colhead{
      padding: 12px 12px 10px;
      display:flex;
      justify-content:space-between;
      align-items:baseline;
      border-bottom: 1px solid rgba(255,255,255,.08);
    }
    .colhead h2{
      margin:0;
      font-size: 14px;
      letter-spacing:.2px;
    }
    .hint{
      margin:0;
      color: var(--muted);
      font-size: 12px;
    }

    .list{
      padding: 12px;
      display:grid;
      grid-template-columns: 1fr;
      gap: 10px;
    }

    .card{
      width:100%;
      text-align:left;
      border-radius: 14px;
      padding: 12px 12px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(24,34,74,.85);
      color: var(--text);
      cursor:pointer;
      font-size: 14px;
      line-height: 1.2;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 10px;
      transition: transform .05s ease, border-color .15s ease, background .15s ease;
    }
    .card:hover{ background: rgba(24,34,74,1); border-color: rgba(255,255,255,.18); }
    .card:active{ transform: translateY(1px); }
    .card:focus{ outline: 2px solid rgba(255,209,102,.45); outline-offset: 2px; }

    .tag{
      font-size: 11px;
      color: var(--muted);
      padding: 5px 8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.05);
      flex: 0 0 auto;
    }

    .selected{
      border-color: rgba(255,209,102,.75) !important;
      box-shadow: 0 0 0 3px rgba(255,209,102,.15);
    }

    .matched{
      cursor:default;
      opacity: .72;
      border-color: rgba(46,229,157,.45) !important;
      background: rgba(46,229,157,.08) !important;
    }
    .matched .tag{
      border-color: rgba(46,229,157,.35);
      color: rgba(46,229,157,.9);
      background: rgba(46,229,157,.10);
    }

    .wrong{
      animation: shake .22s linear;
      border-color: rgba(255,90,122,.7) !important;
      box-shadow: 0 0 0 3px rgba(255,90,122,.16);
    }
    .hintflash{
      border-color: rgba(118,200,255,.78) !important;
      box-shadow: 0 0 0 3px rgba(118,200,255,.22);
    }
    @keyframes shake{
      0%,100%{ transform: translateX(0); }
      25%{ transform: translateX(-4px); }
      75%{ transform: translateX(4px); }
    }

    .footer{
      margin-top: 14px;
      padding: 12px;
      border-radius: var(--radius);
      background: rgba(255,255,255,.04);
      border: 1px solid rgba(255,255,255,.08);
      display:flex;
      flex-wrap:wrap;
      gap: 10px;
      align-items:center;
      justify-content:space-between;
    }
    .status{
      font-size: 13px;
      color: var(--muted);
      display:flex;
      gap: 10px;
      flex-wrap: wrap;
      align-items:center;
    }
    .status strong{ color: var(--text); }
    .status .dot{
      opacity:.55;
      font-size: 12px;
    }
    .toast{
      font-size: 13px;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      color: var(--text);
      min-height: 34px;
      display:flex;
      align-items:center;
      gap: 8px;
    }
    .toast.good{ border-color: rgba(46,229,157,.35); background: rgba(46,229,157,.08); }
    .toast.bad{ border-color: rgba(255,90,122,.35); background: rgba(255,90,122,.08); }
    .toast.warn{ border-color: rgba(255,209,102,.35); background: rgba(255,209,102,.08); }

    .sr-only{
      position:absolute;
      width:1px;height:1px;
      padding:0;margin:-1px;
      overflow:hidden;clip:rect(0,0,0,0);
      white-space:nowrap;border:0;
    }

    .kbd{
      font-size: 11px;
      color: var(--muted);
      margin-left: 2px;
    }

    @media (prefers-reduced-motion: reduce){
      *{
        animation-duration: .01ms !important;
        animation-iteration-count: 1 !important;
        transition-duration: .01ms !important;
        scroll-behavior: auto !important;
      }
    }
  </style>
</head>
<body>
  <div class="app" aria-label="Verb phrase matching game">
    <header>
      <div class="title">
        <h1>Match the Verb + Complement</h1>
        <p class="subtitle">Click one verb, then click the correct complement. Match them all to win.</p>
      </div>
      <div class="controls">
        <div class="pill" aria-live="polite">
          <span>Score:</span> <strong id="score">0</strong>/<span id="total">24</span>
          <span style="opacity:.5">•</span>
          <span>Tries:</span> <strong id="tries">0</strong>
          <span style="opacity:.5">•</span>
          <span>Accuracy:</span> <strong id="accuracy">0%</strong>
        </div>
        <div class="pill" aria-live="polite">
          <span>Time:</span> <strong id="timer">00:00</strong>
          <span style="opacity:.5">•</span>
          <span>Best:</span> <strong id="bestTime">--:--</strong>
          <span style="opacity:.5">•</span>
          <span>Hints:</span> <strong id="hints">0</strong>
        </div>
        <button class="btn" id="hintBtn" type="button" title="Hint (H)">Hint</button>
        <button class="btn" id="resetBtn" type="button">Reset</button>
        <button class="btn" id="shuffleBtn" type="button" title="Shuffle (S)">Shuffle</button>
      </div>
    </header>

    <main>
      <div
        class="progressWrap"
        id="progressWrap"
        role="progressbar"
        aria-label="Match progress"
        aria-valuemin="0"
        aria-valuemax="100"
        aria-valuenow="0"
      >
        <div class="progressBar" id="progressBar"></div>
      </div>
      <div class="grid">
        <section class="col" aria-label="Verb list">
          <div class="colhead">
            <h2>Verbs</h2>
            <p class="hint">Pick one</p>
          </div>
          <div class="list" id="verbList"></div>
        </section>

        <section class="col" aria-label="Complement list">
          <div class="colhead">
            <h2>Complements</h2>
            <p class="hint">Pick one</p>
          </div>
          <div class="list" id="compList"></div>
        </section>
      </div>

      <div class="footer">
        <div class="status" id="status">
          <span>Selected: <strong id="selVerb">none</strong> + <strong id="selComp">none</strong></span>
          <span class="dot" aria-hidden="true">•</span>
          <span>Shortcuts: <strong>R</strong> reset, <strong>S</strong> shuffle, <strong>H</strong> hint</span>
        </div>
        <div class="toast warn" id="toast" aria-live="polite">
          <span aria-hidden="true">Tip</span>
          <span id="toastText">Make a match.</span>
        </div>
      </div>

      <p class="sr-only" id="live" aria-live="assertive"></p>
    </main>
  </div>

  <script>
    // Data: each pair has a shared id so duplicates like "do" or "work" are still unique.
    const PAIRS = [
      { id: 1,  verb: "drink",  comp: "coffee" },
      { id: 2,  verb: "work",   comp: "in an office" },
      { id: 3,  verb: "work",   comp: "in a garden" },
      { id: 4,  verb: "study",  comp: "history" },
      { id: 5,  verb: "speak",  comp: "German" },
      { id: 6,  verb: "live",   comp: "in a flat" },
      { id: 7,  verb: "read",   comp: "a book" },
      { id: 8,  verb: "like",   comp: "animals" },
      { id: 9,  verb: "go",     comp: "to the cinema" },
      { id: 10, verb: "watch",  comp: "TV" },
      { id: 11, verb: "listen", comp: "to music" },
      { id: 12, verb: "play",   comp: "tennis" },
      { id: 13, verb: "take",   comp: "an umbrella" },
      { id: 14, verb: "do",     comp: "housework" },
      { id: 15, verb: "play",   comp: "the guitar" },
      { id: 16, verb: "say",    comp: "sorry" },
      { id: 17, verb: "drink",  comp: "mineral water" },
      { id: 18, verb: "eat",    comp: "vegetables" },
      { id: 19, verb: "cook",   comp: "dinner" },
      { id: 20, verb: "do",     comp: "exercise" },
      { id: 21, verb: "wear",   comp: "glasses" },
      { id: 22, verb: "need",   comp: "a new phone" },
      { id: 23, verb: "drive",  comp: "a car" },
      { id: 24, verb: "do",     comp: "homework" },
    ];

    const verbList = document.getElementById("verbList");
    const compList = document.getElementById("compList");

    const scoreEl = document.getElementById("score");
    const totalEl = document.getElementById("total");
    const triesEl = document.getElementById("tries");
    const accuracyEl = document.getElementById("accuracy");
    const timerEl = document.getElementById("timer");
    const bestTimeEl = document.getElementById("bestTime");
    const hintsEl = document.getElementById("hints");

    const selVerbEl = document.getElementById("selVerb");
    const selCompEl = document.getElementById("selComp");
    const progressWrap = document.getElementById("progressWrap");
    const progressBar = document.getElementById("progressBar");

    const toast = document.getElementById("toast");
    const toastText = document.getElementById("toastText");
    const live = document.getElementById("live");

    const hintBtn = document.getElementById("hintBtn");
    const resetBtn = document.getElementById("resetBtn");
    const shuffleBtn = document.getElementById("shuffleBtn");

    const BEST_TIME_STORAGE_KEY = "verb_phrase_match_best_time_sec";
    totalEl.textContent = String(PAIRS.length);

    let clockId = null;
    let bestTimeSec = loadBestTimeSec();

    let state = {
      selectedVerbId: null,
      selectedCompId: null,
      matchedIds: new Set(),
      score: 0,
      tries: 0,
      hintsUsed: 0,
      elapsedSec: 0,
      startedAtMs: Date.now(),
      completed: false,
      isResolving: false,
      verbs: [],
      comps: []
    };

    function loadBestTimeSec(){
      try{
        const raw = localStorage.getItem(BEST_TIME_STORAGE_KEY);
        const parsed = Number(raw);
        if(Number.isInteger(parsed) && parsed > 0) return parsed;
      } catch(_err){
        return null;
      }
      return null;
    }

    function saveBestTimeSec(value){
      try{
        localStorage.setItem(BEST_TIME_STORAGE_KEY, String(value));
      } catch(_err){
        // Ignore persistence failures (private mode / blocked storage).
      }
    }

    function formatTime(totalSec){
      const mins = Math.floor(totalSec / 60);
      const secs = totalSec % 60;
      return `${String(mins).padStart(2, "0")}:${String(secs).padStart(2, "0")}`;
    }

    function shuffle(arr){
      const a = [...arr];
      for(let i=a.length-1;i>0;i--){
        const j = Math.floor(Math.random()*(i+1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }

    function setToast(kind, msg){
      toast.classList.remove("good","bad","warn");
      toast.classList.add(kind);
      toastText.textContent = msg;
      live.textContent = msg;
    }

    function updateClockDisplay(){
      timerEl.textContent = formatTime(state.elapsedSec);
      bestTimeEl.textContent = bestTimeSec ? formatTime(bestTimeSec) : "--:--";
    }

    function startClock(){
      if(clockId) clearInterval(clockId);
      clockId = setInterval(() => {
        if(state.completed) return;
        state.elapsedSec = Math.floor((Date.now() - state.startedAtMs) / 1000);
        updateClockDisplay();
      }, 250);
    }

    function stopClock(){
      if(clockId){
        clearInterval(clockId);
        clockId = null;
      }
    }

    function render(){
      verbList.innerHTML = "";
      compList.innerHTML = "";

      state.verbs.forEach(item => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "card";
        btn.dataset.id = item.id;
        btn.dataset.side = "verb";
        const isMatched = state.matchedIds.has(item.id);
        btn.innerHTML = `
          <span>${item.verb}</span>
          <span class="tag">verb</span>
        `;
        if(isMatched){
          btn.classList.add("matched");
          btn.disabled = true;
          btn.setAttribute("aria-disabled", "true");
        }
        if(state.selectedVerbId === item.id) btn.classList.add("selected");
        btn.setAttribute("aria-pressed", state.selectedVerbId === item.id ? "true" : "false");
        btn.setAttribute("aria-label", `Verb ${item.verb}`);
        btn.addEventListener("click", onPick);
        verbList.appendChild(btn);
      });

      state.comps.forEach(item => {
        const btn = document.createElement("button");
        btn.type = "button";
        btn.className = "card";
        btn.dataset.id = item.id;
        btn.dataset.side = "comp";
        const isMatched = state.matchedIds.has(item.id);
        btn.innerHTML = `
          <span>${item.comp}</span>
          <span class="tag">complement</span>
        `;
        if(isMatched){
          btn.classList.add("matched");
          btn.disabled = true;
          btn.setAttribute("aria-disabled", "true");
        }
        if(state.selectedCompId === item.id) btn.classList.add("selected");
        btn.setAttribute("aria-pressed", state.selectedCompId === item.id ? "true" : "false");
        btn.setAttribute("aria-label", `Complement ${item.comp}`);
        btn.addEventListener("click", onPick);
        compList.appendChild(btn);
      });

      scoreEl.textContent = String(state.score);
      triesEl.textContent = String(state.tries);
      hintsEl.textContent = String(state.hintsUsed);
      const accuracy = state.tries ? Math.round((state.score / state.tries) * 100) : 0;
      accuracyEl.textContent = `${accuracy}%`;

      const v = state.selectedVerbId
        ? `${PAIRS.find(p=>p.id===state.selectedVerbId).verb}`
        : "none";
      const c = state.selectedCompId
        ? `${PAIRS.find(p=>p.id===state.selectedCompId).comp}`
        : "none";

      selVerbEl.textContent = v;
      selCompEl.textContent = c;

      const progressPct = Math.round((state.score / PAIRS.length) * 100);
      progressBar.style.width = `${progressPct}%`;
      progressWrap.setAttribute("aria-valuenow", String(progressPct));

      updateClockDisplay();
    }

    function clearSelection(){
      state.selectedVerbId = null;
      state.selectedCompId = null;
    }

    function markWrongFeedback(elements){
      elements.forEach(el => {
        el.classList.add("wrong");
        setTimeout(()=>el.classList.remove("wrong"), 240);
      });
    }

    function flashHint(id){
      const verbBtn = verbList.querySelector(`.card[data-id="${id}"]`);
      const compBtn = compList.querySelector(`.card[data-id="${id}"]`);
      [verbBtn, compBtn].forEach(el => {
        if(!el) return;
        el.classList.add("hintflash");
        setTimeout(() => el.classList.remove("hintflash"), 750);
      });
    }

    function finalizeIfComplete(){
      if(state.score !== PAIRS.length || state.completed) return;

      state.completed = true;
      state.elapsedSec = Math.floor((Date.now() - state.startedAtMs) / 1000);
      stopClock();

      const accuracy = state.tries ? Math.round((state.score / state.tries) * 100) : 0;
      if(!bestTimeSec || state.elapsedSec < bestTimeSec){
        bestTimeSec = state.elapsedSec;
        saveBestTimeSec(bestTimeSec);
        setToast("good", `You won in ${formatTime(state.elapsedSec)}. New best time!`);
      } else {
        setToast(
          "good",
          `You won in ${formatTime(state.elapsedSec)} at ${accuracy}% accuracy.`
        );
      }
    }

    function onPick(e){
      const btn = e.currentTarget;
      const id = Number(btn.dataset.id);
      const side = btn.dataset.side;

      if(state.matchedIds.has(id)) return; // already matched, ignore
      if(state.completed) return;
      if(state.isResolving) return;

      if(side === "verb"){
        if(state.selectedVerbId === id){
          state.selectedVerbId = null;
          setToast("warn", "Verb selection cleared.");
          render();
          return;
        }
        state.selectedVerbId = id;
        setToast("warn", "Now pick a complement.");
      } else {
        if(state.selectedCompId === id){
          state.selectedCompId = null;
          setToast("warn", "Complement selection cleared.");
          render();
          return;
        }
        state.selectedCompId = id;
        setToast("warn", "Now pick a verb.");
      }

      // If both selected, evaluate
      if(state.selectedVerbId && state.selectedCompId){
        state.tries += 1;

        const vId = state.selectedVerbId;
        const cId = state.selectedCompId;

        if(vId === cId){
          state.matchedIds.add(vId);
          state.score += 1;
          setToast("good", "Correct match!");
          clearSelection();
          finalizeIfComplete();
          render();
          return;
        } else {
          // wrong: shake the two selected cards
          setToast("bad", "Not a match. Try again.");
          const verbBtn = verbList.querySelector(`.card[data-id="${vId}"]`);
          const compBtn = compList.querySelector(`.card[data-id="${cId}"]`);
          markWrongFeedback([verbBtn, compBtn].filter(Boolean));
          state.isResolving = true;
          setTimeout(() => {
            clearSelection();
            state.isResolving = false;
            render();
          }, 260);
          return;
        }
      }

      finalizeIfComplete();
      render();
    }

    function shuffleUnmatched(list){
      const unmatched = list.filter(item => !state.matchedIds.has(item.id));
      const shuffled = shuffle(unmatched);
      let idx = 0;
      return list.map(item => (
        state.matchedIds.has(item.id) ? item : shuffled[idx++]
      ));
    }

    function giveHint(){
      if(state.completed){
        setToast("warn", "Game complete. Press Reset to play again.");
        return;
      }

      const remaining = PAIRS.filter(pair => !state.matchedIds.has(pair.id));
      if(!remaining.length) return;

      const choice = remaining[Math.floor(Math.random() * remaining.length)];
      state.hintsUsed += 1;
      clearSelection();
      render();
      flashHint(choice.id);
      setToast("warn", `Hint: match "${choice.verb}" with "${choice.comp}".`);
    }

    function startGame(){
      stopClock();
      state = {
        selectedVerbId: null,
        selectedCompId: null,
        matchedIds: new Set(),
        score: 0,
        tries: 0,
        hintsUsed: 0,
        elapsedSec: 0,
        startedAtMs: Date.now(),
        completed: false,
        isResolving: false,
        verbs: shuffle(PAIRS.map(({id,verb}) => ({id,verb}))),
        comps: shuffle(PAIRS.map(({id,comp}) => ({id,comp})))
      };
      setToast("warn", "Make a match.");
      startClock();
      render();
    }

    resetBtn.addEventListener("click", startGame);

    hintBtn.addEventListener("click", giveHint);

    shuffleBtn.addEventListener("click", () => {
      if(state.completed){
        setToast("warn", "Game complete. Press Reset to play again.");
        return;
      }
      state.verbs = shuffleUnmatched(state.verbs);
      state.comps = shuffleUnmatched(state.comps);
      clearSelection();
      setToast("warn", "Shuffled. Keep going.");
      render();
    });

    window.addEventListener("keydown", (e) => {
      const key = e.key.toLowerCase();
      if(key === "r"){
        e.preventDefault();
        startGame();
      } else if(key === "s"){
        e.preventDefault();
        shuffleBtn.click();
      } else if(key === "h"){
        e.preventDefault();
        hintBtn.click();
      }
    });

    startGame();
  </script>
</body>
</html>
